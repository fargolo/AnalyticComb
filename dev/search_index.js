var documenterSearchIndex = {"docs":
[{"location":"functions/","page":"Function definitions","title":"Function definitions","text":"CurrentModule = AnalyticComb","category":"page"},{"location":"functions/","page":"Function definitions","title":"Function definitions","text":"","category":"page"},{"location":"functions/","page":"Function definitions","title":"Function definitions","text":"Modules = [AnalyticComb]","category":"page"},{"location":"functions/#AnalyticComb.CYC-Tuple{Any, Any}","page":"Function definitions","title":"AnalyticComb.CYC","text":"CYC(z,max)\n\nCycle operator (Pólya logarithm).  \n\nDefined as A = CYC(B) implies A(z) = sum_1^infty fracphi(k)k log frac11-z^k.\n\n\n\n\n\n","category":"method"},{"location":"functions/#AnalyticComb.I_gf-Tuple{Any}","page":"Function definitions","title":"AnalyticComb.I_gf","text":"I_gf(z)\n\nIntegers as combinatorial structures \n\nI(z)= sum_n geq 1 z^n = fracz1-z\n\n\n\n\n\n","category":"method"},{"location":"functions/#AnalyticComb.MSET-Tuple{Any, Any}","page":"Function definitions","title":"AnalyticComb.MSET","text":"MSET(z,max)\n\nMultiset operator (Pólya exponential operator).  \n\nDefined as A = MSET(B) implies A(z) = exp(sum_1^infty frac1k B(z^k)).\n\n\n\n\n\n","category":"method"},{"location":"functions/#AnalyticComb.PSET-Tuple{Any, Any}","page":"Function definitions","title":"AnalyticComb.PSET","text":"PSET(z,max)\n\nPowerset operator (modified Pólya exponential operator).  \n\nDefined as A = PSET(B) implies A(z) = exp(sum_1^infty frac(-1)^k-1k B(z^k)).\n\n\n\n\n\n","category":"method"},{"location":"functions/#AnalyticComb.SEQ-Tuple{Any}","page":"Function definitions","title":"AnalyticComb.SEQ","text":"SEQ(z)\n\nSequence operator (Pólya quasi-inverse operator).   \n\nDefined as A = SEQ(B) implies A(z) = frac11 - B(z).\n\n\n\n\n\n","category":"method"},{"location":"functions/#AnalyticComb.W_coeff-Tuple{Any}","page":"Function definitions","title":"AnalyticComb.W_coeff","text":"W_coeff(r;n_tot=200)\n\nTaylor series coefficient from generating function for binary words that never have more than r consecutive identical letters. \n\nThe number of binary words that never have more than r consecutive identical letters is found to be (set α = β = r). n_tot defaults to 200, according to the example in Flajolet & Sedgewick pag. 52\n\n\n\n\n\n","category":"method"},{"location":"functions/#AnalyticComb.p_binary_words_doub_runl-Tuple{Any, Any}","page":"Function definitions","title":"AnalyticComb.p_binary_words_doub_runl","text":"p_binary_words_doub_runl(k,n)\n\nReturns probablity associatied with k-lenght double runs (or either 0s or 1s) in a sequence of size n. \n\nSpecification is W ∼= SEQ(b) SEQ(a SEQ(a) b SEQ(b)) SEQ(a). Refer to the example in Flajolet & Sedgewick pag. 52.  \n\n\n\n\n\n","category":"method"},{"location":"functions/#AnalyticComb.partitions_asym-Tuple{Any}","page":"Function definitions","title":"AnalyticComb.partitions_asym","text":"partitions_asym(n)\n\nAsymptotics for partition of integers (EIS A000041) by Hardy and Ramanujan, later improved by Rademache\n\n\n\n\n\n","category":"method"},{"location":"functions/#AnalyticComb.partitions_gf-Tuple{Any, Any}","page":"Function definitions","title":"AnalyticComb.partitions_gf","text":"partitions_gf(z,max)\n\nGenerating function for integer partitions.\n\nDefined as P(z) = prod_m = 1^infty frac11-z^m   Use series to obtain counts(EIS A000041): series(partitions_gf(z,10),z,0,8) for n up to 8.\n\n\n\n\n\n","category":"method"},{"location":"functions/#AnalyticComb.primes_composition_asym-Tuple{Any}","page":"Function definitions","title":"AnalyticComb.primes_composition_asym","text":"primes_composition_asym(n)\n\nAsymptotics for composition of n into prime parts (EIS A023360).\n\nB_n sim 030365 * 147622^n\n\n\n\n\n\n","category":"method"},{"location":"functions/#AnalyticComb.restricted_sum_comp-Tuple{Any, Any}","page":"Function definitions","title":"AnalyticComb.restricted_sum_comp","text":"restricted_sum_comp(n,r)\n\nNumber of compositions of n with components in the set {1,2,..,r}. \n\nr = 2 yields Fibonnaci numbers (EIS A000045): F_n = F_n-1 + F_n-2.   r>2 yields generalized Fibonacci numbers.\n\n\n\n\n\n","category":"method"},{"location":"functions/#AnalyticComb.restricted_sum_comp_gf-Tuple{Any}","page":"Function definitions","title":"AnalyticComb.restricted_sum_comp_gf","text":"restricted_sum_comp_gf(r)\n\nGenerating function for compositions with restricted summand.\n\n\n\n\n\n","category":"method"},{"location":"functions/#AnalyticComb.restricted_sum_part-Tuple{Any, Any}","page":"Function definitions","title":"AnalyticComb.restricted_sum_part","text":"restricted_sum_part(n,r)\n\nNumber of partitions with components in r with restricted summand n.\n\nn must be an integer and r must be a set of integers, like in r = [1,5,10,25] , n = 99.\n\n\n\n\n\n","category":"method"},{"location":"functions/#AnalyticComb.restricted_sum_part_gf-Tuple{Any}","page":"Function definitions","title":"AnalyticComb.restricted_sum_part_gf","text":"restricted_sum_part_gf(r)\n\nGenerating function for partition with restricted summand.\n\n\n\n\n\n","category":"method"},{"location":"functions/#AnalyticComb.stirling_catalan_asym-Tuple{Any}","page":"Function definitions","title":"AnalyticComb.stirling_catalan_asym","text":"stirling_catalan_asym(n)\n\nStirling approximation for n_th Catalan number. (EIS A000108)\n\nC_n sim frac4^nsqrtpi n^3\n\n\n\n\n\n","category":"method"},{"location":"functions/#AnalyticComb.stirling_factorial_asym-Tuple{Any}","page":"Function definitions","title":"AnalyticComb.stirling_factorial_asym","text":"stirling_factorial_asym(n)\n\nStirling approximation for n! (EIS A000142)\n\nn sim sqrt2 pi n fracne^n\n\n\n\n\n\n","category":"method"},{"location":"examples/#Binary-word-double-runs","page":"Examples","title":"Binary word double runs","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Probability for consecutive double runs (either 0s or 1s) of lenght k in binary words of length n, use p_binary_words_doub_runl(k,n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia>using AnalyticComb\njulia>p_binary_words_doub_runl(6,200) #e.g. 100000011010... or 01111110101...\n0.166...","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Stirling approximation for n!:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> stirling_factorial(7)\n4980.395831612462","category":"page"},{"location":"examples/#Restricted-summands-problem","page":"Examples","title":"Restricted summands problem","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Using SEQ operator to solve Polya partitions with restricted summands (denumerants) problem (see Flajolet & Sedgewick,p. 43) about the number of ways of giving change of 99 cents using pennies (1 cent), nickels (5 cents), dimes (10 cents) and quarters (25 cents).  ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> restricted_sum_part_gf([1,5,10,25]) # examine the generating function SEQ(z)*SEQ(z^5)*SEQ(z^10)*SEQ(z^25)\n                 1                  \n────────────────────────────────────\n        ⎛     5⎞ ⎛     10⎞ ⎛     25⎞\n(1 - z)⋅⎝1 - z ⎠⋅⎝1 - z  ⎠⋅⎝1 - z  ⎠\n\njulia>restricted_sum_part(99,[1,5,10,25]) # Counts for 99 as a sum of elements in (1,5,10,25).\n213","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Python package sympy is required. SymPy.jl functionalities are reexported in AnalyticComb.jl.   ","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"$python -m pip install --upgrade pip\n$pip install sympy","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Then, from Julia:  ","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg>add AnalyticComb","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = AnalyticComb","category":"page"},{"location":"#AnalyticComb","page":"Introduction","title":"AnalyticComb","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Documentation for AnalyticComb.","category":"page"},{"location":"#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package implements solutions for combinatorial problems using analytic combinatorics. Check the text book by Flajojelt & Sedgewick ( https://algo.inria.fr/flajolet/Publications/book.pdf ) and Coursera's full course by Robert Sedgewick ( https://www.coursera.org/learn/analytic-combinatorics ).  ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"I thank Ricardo Bittencourt ( https://github.com/ricbit/ ) for his introductory texts on the subject and for helping in an initial implementation.  ","category":"page"},{"location":"#Background","page":"Introduction","title":"Background","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"In, 1751, Euler was studying the number of ways in which a given convex polygon could be decomposed into triangles by diagonal lines. (Flajolet & Sedgewick, p.20)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"He realized that the progression of numbers in the solution (1, 2, 5, 14, 42, 132,...) was directly related to the coefficients of the series expansion of the polynomial fraction (1−2a−√(1−4a)) / (2aa), that is: 1+2a +5a^2 + 14a^3 + 42a^4 + 132a^5 + ...","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Given any constructable combinatorial structure, one can use a set of operators to find a generating function and then approach the problem analytically.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"For newcomers, this an analytic approach to combinatorial problems. Modelling this type of problem often relies on intuitive arguments. Analytic combinatorics describe such situations with a grammar of operators: Sum, Cartesian product, Sequence, Multiset, Powerset and Cycle. Such operators yield an algebraic expression (e.g. P(z)), called the generating function, which is directly related to the problem via complex analysis. We are generally interested in the coefficients of its series expansion. That is, let the series expansion of P(z) be T(P(z)) = sum_n=1^infty a_n x^n. Then, the values of a^n correspond to the counts of objects of size n in this combinatorial class.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For instance, the number of binary words (e.g. abababbabab...) of size n is given by W_n = 2^n. Using the sequence operator (SEQ(A) implies A(z) = frac11-z) , we find the generating function: W = SEQ(Z+Z) implies W(z) = frac11 - 2z. T(W(z)) = 1 + 2z + 4z^2 + 8z^3 + .  ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This approach can be used to solve complex problems in a systematic way.    ","category":"page"}]
}
